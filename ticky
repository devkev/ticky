#!/bin/bash

ticky_dir="${TICKY_DIR:-$HOME/.ticky}"
( umask 077 ; mkdir -p "$ticky_dir" )

config_file="${TICKY_CONFIG:-$ticky_dir/config}"
[ -r "$config_file" ] && . "$config_file"

login_file="${login_file:-$ticky_dir/.login}"
cookie_file="${cookie_file:-$ticky_dir/.cookie}"
backup_dir="${backup_dir:-$ticky_dir/backups}"
batch_file="${batch_file:-$ticky_dir/.batch}"

api_hostname="api.ticktick.com"
api_base="https://$api_hostname/api/v2/"
cookie_expiry="2147483647"  # shoot me in 2038

mongodb_endpoint="mongodb://localhost:27017/ticky"

function __gettoken {
	if type -t jq > /dev/null; then
		jq -r '.token' < "$login_file"
	else
		awk '{printf("%s%s", NR==1?"":" ", $0)}' < "$login_file" | sed -e 's/^.*"token":"//' -e 's/".*$//'
	fi
}

function __generate_cookie_file {
	(
		umask 077
		{
			echo -ne "$api_hostname\tFALSE\t/\tTRUE\t${cookie_expiry}\tt\t"
			__gettoken
		} > "$cookie_file"
	)
}

function _ticky_login {
	umask 077
	pass web/ticktick \
		| awk 'NR==1{p=$0} NR>2 && $1 == "Username:" {u=$2} END{printf("{\"username\":\"%s\",\"password\":\"%s\"}",u,p)}' \
		| curl --silent --show-error -d '@-' -H 'Content-Type: application/json' "$api_base"'user/signon?wc=true&remember=true' \
		> "$login_file"
	__generate_cookie_file
}

function _ticky_export {
	curl --silent --show-error --cookie "$cookie_file" "$api_base"'data/export' | jq -r .
}

function _ticky_backup {
	umask 077
	mkdir -p "$backup_dir"
	local file="$(date '+%Y%m%d-%H%M%S').csv"
	if _ticky_export > "$backup_dir/$file"; then
		xz "$backup_dir/$file"
	fi
}

function _ticky_sync {

	checkPoint="$(mongo "$mongodb_endpoint" --quiet --eval 'var c = db.tasks.find({_id:"checkPoint"}); c.hasNext() ? ((cp = c.next()).checkPoint ? cp.checkPoint : NumberLong("0")) : NumberLong("0")' | sed -e 's/^NumberLong("\?//' -e 's/"\?)$//')"

	if [ "$checkPoint" = "" -o "$checkPoint" = "0" ]; then
		# Full initial sync
		checkPoint=0
		# FIXME: get completed tasks
	fi

	curl --silent --show-error --cookie "$cookie_file" "$api_base"'batch/check/'"$checkPoint" \
		| tee "$batch_file" \
		| jq '
			def xjson($type; $field):
				if has($field) then ( .[$field] as $orig | .[$field] = {} | .[$field][$type] = $orig ) else . end
				;

			(
			.syncTaskBean.update[]
				| .["_id"] = .id | del(.id)
				| xjson("$oid"; "_id")
				| xjson("$oid"; "repeatTaskId")
				| xjson("$date"; "startDate")
				| xjson("$date"; "dueDate")
				| xjson("$date"; "repeatFirstDate")
				| xjson("$date"; "modifiedTime")
				| xjson("$date"; "createdTime")
				| xjson("$date"; "completedTime")
			)
			,

			{ "_id": "checkPoint", "checkPoint": .checkPoint }
			,

			if .inboxId != null then
				{ "_id": "inboxId", "inboxId": .inboxId }
			else
				empty
			end
		' \
		| mongoimport --quiet --mode=upsert --uri "$mongodb_endpoint" -c tasks

	# FIXME: do the upsert of all the stuff, and the update of checkPoint, in a transaction?

	# FIXME: what about .syncTaskBean.delete and .syncTaskBean.add?

	# FIXME: handle `projectProfiles` and `projectGroups`.

	# FIXME: handle `filters` (looks like they have embedded string mql?)

	# FIXME: handle `tags`

}

function _ticky_date {
	mongo "$mongodb_endpoint" --quiet --eval '
		var targetdate = '"$1"';
		var heading = "'"$2"'";
		var trailingBlankLine = '"${3:-false}"';
		var first = true;

		var ESC = String.fromCharCode(0x1B);
		var normal = ESC + "[0000m";
		var red = ESC + "[1;31m";
		var green = ESC + "[0032m";
		var white = ESC + "[1;37m";
		var yellow = ESC + "[0033m";
		var NBSP = String.fromCharCode(0xA0);

		var inboxId = db.tasks.findOne( { _id: "inboxId" } ).inboxId;

		db.tasks.aggregate( [
			{ $match: { projectId: inboxId, status: 0, deleted: 0, dueDate: { $exists: true } } },
			{ $addFields: { day: { $dateToString: { date: "$dueDate", format: "%Y%m%d", timezone: "$timeZone" } } } },
			{ $match: { day: targetdate } },
			{ $sort: { day: 1, isAllDay: 1, dueDate: 1, priority: -1, sortOrder: 1 } },
			{ $project: { _id: 0, priority: 1, title: 1, dueDate: 1 } },
		] ).forEach(function (task) {
			var prefix = normal;
			var suffix = normal;
			if (first) {
				first = false;
				if (heading) {
					print(white + heading + NBSP + NBSP + normal);
				}
			}
			if (task.priority == 3) {
				prefix = yellow;
				suffix = normal;
			} else if (task.priority == 5) {
				prefix = red;
				suffix = normal;
			}
			print(prefix + " â–¡ " + task.title + suffix);
			//print(prefix + " x " + task.title + suffix);
		});
		if (trailingBlankLine) {
			print(normal + NBSP + NBSP + normal);
		}
		'
}

function _ticky_today {
	_ticky_date "\"$(date "+%Y%m%d")\"" "TODAY" true
}

function _adjacent_day {
	date -d "@$(( $(date "+%s") + 86400 * $1 ))" "+%Y%m%d"
}

function _ticky_adjacent_day {
	_ticky_date "\"$(_adjacent_day "$1")\"" "$2" "$3"
}

function _ticky_tomorrow {
	_ticky_adjacent_day 1 "Tomorrow" true
}

function _ticky_yesterday {
	_ticky_adjacent_day -1 "Yesterday" true
}

function _ticky_earlier {
	_ticky_adjacent_day -2 "Earlier"
	_ticky_adjacent_day -3
	_ticky_adjacent_day -4
	_ticky_adjacent_day -5
	_ticky_adjacent_day -6
	_ticky_adjacent_day -7 "" true
}

function _ticky_rest_of_week {
	_ticky_adjacent_day 2 "Rest of week"
	_ticky_adjacent_day 3
	_ticky_adjacent_day 4
	_ticky_adjacent_day 5
	_ticky_adjacent_day 6 "" true
}

function _ticky_later {
	_ticky_date "{ \$gt: \"$(_adjacent_day 6)\" }" "Later" true
}

function _ticky_overdue {
	_ticky_date "{ \$lt: \"$(date "+%Y%m%d")\" }" "Overdue" true
}

function _ticky_backlog {
	echo "Backlog"
	# FIXME
}

function _ticky_summary {
	_ticky_yesterday
	_ticky_today
	_ticky_tomorrow
}

_NL='
'
pad_blank_line="$(echo -ne '\e[0000m\ua0\ua0\e[0000m')"

function _ticky_all {
	#col1="$(_ticky_yesterday ; _ticky_overdue)"
	col1="$(_ticky_yesterday ; _ticky_earlier)"
	col2="$(_ticky_today ; _ticky_tomorrow)"
	col3="$(_ticky_rest_of_week ; _ticky_later)"

	col1_width="$(awk '{if (m < length) m = length} END {print m}' <<<"$col1")"
	col2_width="$(awk '{if (m < length) m = length} END {print m}' <<<"$col2")"
	col3_width="$(awk '{if (m < length) m = length} END {print m}' <<<"$col3")"

	col1_lines="$(wc -l <<<"$col1")"
	col2_lines="$(wc -l <<<"$col2")"
	col3_lines="$(wc -l <<<"$col3")"

	max_lines="$(echo -e "$col1_lines\n$col2_lines\n$col3_lines" | awk '{if (m < $1) m = $1} END {print m}')"

	local i
	for (( i = col1_lines ; i < max_lines ; i++ )); do
		col1="${col1}$_NL$pad_blank_line"
	done
	for (( i = col2_lines ; i < max_lines ; i++ )); do
		col2="${col2}$_NL$pad_blank_line"
	done
	for (( i = col3_lines ; i < max_lines ; i++ )); do
		col3="${col3}$_NL$pad_blank_line"
	done

	paste <(cat <<<"$col1") <(cat <<<"$col2") <(cat <<<"$col3") | expand -t "$(( $col1_width + 3 )),+$(( $col2_width + 3 ))"

#  Backlog  |  Yesterday morning  |  Today morning      |  Rest of week (remaining 5 days)
#           |  Yesterday daytime  |  Today daytime      |
#           |  Yesterday evening  |  Today evening      |  Later (next week onwards)
#           |                     |                     |
#           |  Overdue            |  Tomorrow morning   |
#           |                     |  Tomorrow dayime    |
#           |                     |  Tomorrow evening   |

}


function _ticky_ {
	_ticky_help "$@"
}

function _ticky_help {
	echo "Usage: ticky <fn> <args>"
	echo
	echo "Functions:"
	declare -F | sed -ne 's/^declare -f _ticky_\(.\)/  \1/p'
}

_ticky_"$@"

